import { Callout } from "nextra/components";

# Test Contract

**xSuite** can be used to easily test contracts by abstracting away the [MultiversX Serialization Format](https://docs.multiversx.com/developers/developer-reference/serialization-format) as well as providing other useful helpers.

Under the hood, **xSuite** uses the same test engine as the [MultiversX Scenarios (Mandos)](https://docs.multiversx.com/developers/scenario-reference/overview) tests, but allows you to write everything in easy to learn Javascript code.

## Your first test

Make sure to have followed the [Getting Started](/) guide and already have **xSuite** set up and running for your contract(s).

A test is just a `.ts` (or `.js`) file in the `tests` directory, which uses `xSuite` abstractions and is run using [vitest](https://vitest.dev/guide/). Below we will detail how to write a basic test for checking if the contract was deployed successfully.

Let's start by first creating a `tests/contract.test.ts` file.

### Required imports

The following imports are needed at the top of the file:

```ts
import { test, beforeEach, afterEach } from "vitest";
import { assertAccount } from "xsuite/assert";
import { FWorld, FWorldWallet, FWorldContract } from "xsuite/world";
import { e } from "xsuite/data";
```

We use the `test`, `beforeEach` and `afterEach` hooks from `vitest`. These are functions in which we will write our test's code as well as code that we want to run before/after each test respectively.

`assertAccount` is used to assert that an address (account) on MultiversX contains the data we expect (token balances, storage keys etc).

The `xsuite/world` and `xsuite/data` imports will be detailed later.

### "Fake" world, wallet & contract

Next, we need to define some variables:

```ts
let world: FWorld;
let deployer: FWorldWallet;
let contract: FWorldContract;
```

The `FWorld` represents a "Fake" World, i.e. the MultiversX blockchain. It abstracts away all the interaction with the underlying test MultiversX blockchain.

The `FWorldWallet` and `FWorldContract` represents a wallet and a contract respectively, that are deployed on the "Fake" World (test blockchain).

### beforeEach & afterEach hooks (initializing variables)

Now that we have defined the imports and the variables, we need to initialize them.

```ts
beforeEach(async () => {
  world = await FWorld.start();
  deployer = await world.createWallet();
  ({ contract } = await deployer.deployContract({
    code: "file:output/contract.wasm",
    codeMetadata: [],
    gasLimit: 10_000_000,
    codeArgs: [e.Str("ourString")],
  }));
});

afterEach(async () => {
  await world.terminate();
});
```

First, we need to start the underlying MultiversX blockchain and store it in a variable using `FWorld.start()`. After the test is done, we need to also stop the underlying blockchain using `await world.terminate()` in the `afterEach` hook.

We also create the `deployer` wallet using `world.createWallet()`, which will be used to deploy our contract using `deployer.deployContract()`. This will deploy the contract with the specified code file and the specified `init` arguments.

The `e` is a helper that lets you easily encode data in the format that the MultiversX blockchain understands. Here, `e.Str()` will convert the data in a format that can be recognized by the `ManagedBuffer` type in a Rust Smart Contract.

More details about encoding blockchain data on the [Data Encoding](/data-encoding) page.

### Test case

Finally, we can write our first basic test case:

```ts
test("Test", async () => {
  assertAccount(await contract.getAccountWithPairs(), {
    balance: 0n,
    hasPairs: [
      e.p.Mapper("ourStringStorageKey").Value(e.Str("ourString")),
    ],
  });
});
```

Here, using `assertAccount`, we will test that the contract we deployed has the correct balance and storage keys we expect. `contract.getAccountWithPairs()` will fetch the account of the contract with all it's pairs from the underlying blockchain.

Using `hasPairs` we can test that the contract contains the pairs provided (use `allPairs` if you want to test that only the pairs provided exist).

The `e.p` is a helper that lets you easily encode storage mappers in the format that the MultiversX blockchain understands. Here, `e.p.Mapper()` represents a simple `SingleValueMapper` type from a Rust Smart Contract. Using `.Value()` we can assert that it contains the value we expect.

More details about storage mappers [here](/data-encoding#storage-mappers).

### Full basic test file code

```ts
// tests/contract.test.ts
import { test, beforeEach, afterEach } from "vitest";
import { assertAccount } from "xsuite/assert";
import { FWorld, FWorldWallet, FWorldContract } from "xsuite/world";

let world: FWorld;
let deployer: FWorldWallet;
let contract: FWorldContract;

beforeEach(async () => {
  world = await FWorld.start();
  deployer = await world.createWallet();
  ({ contract } = await deployer.deployContract({
    code: "file:output/contract.wasm",
    codeMetadata: [],
    gasLimit: 10_000_000,
    codeArgs: [e.Str("ourString")],
  }));
});

afterEach(async () => {
  await world.terminate();
});

test("Test", async () => {
  assertAccount(await contract.getAccountWithPairs(), {
    balance: 0n,
    hasPairs: [
      e.p.Mapper("ourStringStorageKey").Value(e.Str("ourString")),
    ],
  });
});
```

## Creating wallets

You can create wallets from a `FWorld` object using the `createWallet` method. When creating a wallet you can specify it's EGLD balance as well as other pairs, like ESDT tokens or storage keys.

```ts
const deployer: FWorldWallet = await world.createWallet({
  balance: 10_000_000_000n,
  pairs: [
    e.p.Esdts([
      { id: "TOKEN-123456", amount: 100_000 },
    ])
  ],
});
```

## Contract operations

### Deploying contracts

Contracts can be deployed by an `FWorldWallet` object

```ts
const { contract, address } = await deployer.deployContract({
  code: "file:output/contract.wasm",
  codeMetadata: ["upgradeable"],
  gasLimit: 100_000_000,
  codeArgs: [
    e.Str('ourString'),
  ],
}));
```

The `contract` is an instance of `FWorldContract` and `address` is a string with the Bech32 address of the contract.

When deploying a contract you can specify:

- `code` - in this case from a wasm file, but it can also be a string of the full contract code
- `codeMetadata` - flags like `upgradeable`, `payable` etc,
- `gasLimit` - the gas limit to use for the transaction
- `codeArgs` - arguments used in the `init` function of the contract

Use the `e` helper utility to encode the data (see [Data Encoding](/data-encoding)).

### Calling contracts

Contracts can be easily called from a `FWorldWallet` object using the `callContract` method and specifying which contract to call in the `callee` field.

```ts
const result = await wallet.callContract({
  callee: contract,
  gasLimit: 5_000_000,
  funcName: "addWhitelistedToken",
  funcArgs: [e.Str("TOKEN-123456")],
  value: 1_000, // egld to send in the transaction
});
```

The `result` contains the `tx` (transaction) and `returnData` fields.

#### Sending ESDTs

To call a contract with ESDT tokens use the `esdts` field:

```ts
const result = await wallet.callContract({
  callee: contract,
  gasLimit: 20_000_000,
  funcName: "swap",
  funcArgs: [
    e.Str("TOKEN-123456"),
  ],
  esdts: [{ id: "TOKEN-123456", amount: BigInt(1_000) }],
});
```

#### Checking errors

You can also easily assert that a transaction failed with the appropriate code or message using the `assertFail` method:

```ts
await deployer.callContract({
  callee: contract,
  gasLimit: 10_000_000,
  funcName: "test",
  funcArgs: [],
}).assertFail({ code: 4, message: "Some error" });
```

### Querying contracts

You can query a contract directly from a `FWorld` object using the `query` method and specifying which contract to query in the `callee` field.

```ts
const { returnData, returnCode, returnMessage } = await world.query({
  callee: contract,
  funcName: "getWhitelistedToken",
  funcArgs: [e.Str("TOKEN-123456")],
});
```

In order to decode the `returnData` you can use the `d` helper from the `xsuite/data` package. More info [here](/encoding#data-decoding).

```ts
import { assert } from "vitest";
import { d } from "xsuite/data";

const tokenData = d.Tuple({
  token: d.Str(),
}).topDecode(returnData[0]);

assert(tokenData.token === "TOKEN-123456");
```

## Asserting account data

### Pairs & accounts

In MultiversX, ESDT and storage data is actually stored in the same place, the `pairs` of an account. That is why all the objects that abstract the blockchain from **xSuite** use the general term `pairs` instead of specifying separately the ESDT and storage data.

An account is an address that exists on the MultiversX blockchain. It can represent a simple wallet address or a smart contract address (which have an additional `code` field). Since they are both accounts, they can both have ESDTs or storage data associated with them.

We can assert that an account has the pairs we want using `assertAccount` function. Here, we have two fields we can use:

- `hasPairs` - will check if the account has the pairs we want, but the account can also have other pairs that we have not specified
- `allPairs` - will check if the account has these EXACT pairs we want, if it has extra pairs the assertion will fail (this is similar to how MultiversX Scenarios work)

You can use whichever works best for you, but we recommend using `allPairs` to make sure your contract doesn't have any unwanted side effects. But sometimes it may be easier to use `hasPairs`, when there are a lot of storage keys or when debugging why some storage keys were set/not set.

### Checking balance & ESDTs

We can use the `assertAccount` function to test that an account has a specific EGLD balance and has specific ESDTs. The ESDTs can be Simple tokens (fungible), NFTs or SFTs.

```ts
const pairs = await contract.getAccountWithPairs();
assertAccount(pairs, {
  balance: 1_000,
  allPairs: [
    e.p.Esdts([
      { id: "TOKEN-123456", amount: 2_000 },
      { id: "NFT-123456", nonce: 1, name: "Nft Name", uris: ["url"] },
      { id: "SFT-123456", nonce: 1, amount: 3_000, name: "Sft Name", uris: ["url"] },
      { id: "META-123456", nonce: 1, amount: 3_000, attrs: e.Tuple(e.Str("test")) },
    ]),
  ],
});
```

### Checking storage data

The helper `e.p` can be used to check storage data. More details about storage mappers encoding [here](/encoding#storage-mappers).

```ts
const pairs = await contract.getAccountWithPairs();
assertAccount(pairs, {
  balance: 0n,
  allPairs: [
    e.p.Mapper("pause_module:paused").Value(e.Bool(false)),
    e.p.Mapper("fee_percent").Value(e.U64(100)),
  ],
});
```

## Mocking account data

Sometimes it is hard to arrive to a specific state of your smart contract, maybe because it will take too many transactions to arrive to that state or because there are some tricky errors that appear only in very specific cases. In those cases you can directly set the storage keys of a smart contract or any ESDTs amount & roles to whatever you want using the `contract.setAccount()` function:

```ts
await contract.setAccount({
  ...(await contract.getAccount()),
  owner: deployer,
  codeMetadata: ["upgradable", "payable"],
  pairs: [
    // Manually setting storage keys
    e.p.Mapper("mock_address").Value(e.Addr(mockAddress)),
    e.p.Mapper("supported_tokens", e.Str("TOKEN-123456")).Value(e.Tuple(
      e.U8(1),
      e.Str("OTHER-654321"),
      e.U(0),
    )),

    // Manually setting ESDTs & roles
    e.p.Esdts([{ id: "TOKEN-123456", amount: 1_000, roles: ["ESDTRoleLocalBurn", "ESDTRoleLocalMint"] }]),
  ],
});
```

This override the `pairs` of the account to what we set here. Make sure to also specify the `owner` and appropriate `codeMetadata` for the contract since they will be lost when using the `setAccount` function.

<Callout type="warning" emoji="⚠️">
  Due to a current bug in the underlying MultiversX Scenarios library, you
  should always specify `payable` in the `codeMetadata` of the `setAccount`
  method in order for payable endpoints to continue to work properly.
</Callout>

## Advanced tests

Using **xSuite** you can write even advanced tests easily.

```ts
test("Validate", async () => {
  await contract.setAccount({
    ...(await contract.getAccount()),
    owner: deployer,
    codeMetadata: ["payable"],
    pairs: [
      // Manually set next_epoch
      e.p.Mapper("next_epoch", e.Str("TOKEN-123456")).Value(e.U64(10)),
    ],
  });

  await deployer.callContract({
    callee: contract,
    gasLimit: 10_000_000,
    funcName: "validate",
    funcArgs: [
      e.Str("TOKEN-123456"),
    ],
    value: 1_000,
  }).assertFail({ code: 4, message: "Invalid epoch" });

  world.setCurrentBlockInfo({
    epoch: 10,
  });

  await deployer.callContract({
    callee: contract,
    gasLimit: 10_000_000,
    funcName: "validate",
    funcArgs: [
      e.Str("TOKEN-123456"),
    ],
    value: 1_000,
  });

  let pairs = await contract.getAccountWithPairs();
  assertAccount(pairs, {
    balance: 1_000, // Assert that balance changed
    allPairs: [
      // Test that next_epoch was modified accordingly
      e.p.Mapper("next_epoch", e.Str("TOKEN-123456")).Value(e.U64(20)),
    ],
  });

  let pairsDeployer = await deployer.getAccountWithPairs();
  assertAccount(pairsDeployer, {
    balance: 0, // Assuming initial balance was 1_000 for deployer
  });
});
```

Above we first mock the account data to set it to what we want using `setAccount`. Then we do a contract call using `callContract` which fails, and we can assert that using `assertFail`.
Then, we set the world `epoch` to what we want and do the transaction again, this time we expect it to succeed.

Then we check that the `pairs` of the contract and the deployer account changed to what we expect.
In this case `next_epoch` value was changed to `20` and `1_000` EGLD was transfered from the deployer account to the contract.

## The FWorld object

The `FWorld` class represents an abstraction over a mock MultiversX blockchain and allows you to easily interact with it. It provides helper functions to managed accounts, deploy contracts and do transactions. Below are a list of the most relevant functions that the class provides:

- `static start({ gasPrice, }?: { gasPrice?: number; }): Promise<FWorld>` - starts an underlying blockchain and creates a new instance of the class; you can optionally specify the `gasPrice`
- `newContract(address: string | Uint8Array): FWorldContract;` - creates a new `FWorldContract` instances for the specified address
- `createWallet(account?: Omit<Account, "address">): Promise<FWorldWallet>;` - creates a new wallet account on the blockchain
- `setAccount(account: Account): Promise<any>;` - allows to set the data of an account on the blockchain; this is useful for setting storage keys or ESDTs directly for a contract
- `setCurrentBlockInfo(block: Block): Promise<any>;` - allows to set current block info, like the timestamp, nonce, round & epoch:

```ts
world.setCurrentBlockInfo({
  nonce: 0,
  epoch: 0,
});
```

- `terminate(): Promise<void>;` - stops the underlying blockchain; should be called in `afterEach` to make sure that the underlying blockchain is properly shutdown

The class also inherits from the `World` class, so it has all the functions form that class as well, like `deployContract`, `callContract` and `query`. Checkout out [here](/interact#the-world-object) for more information about that.

The functions from above that are related to accounts also have wrappers in the `FWorldWallet` and `FWorldContract` classes, for easier interaction.
